#!/usr/bin/env python3
# mel ‚Äî "melcurial" helper for non-git folks
# Commands:
#   mel start [name]
#   mel save
#   mel deploy
#   mel freshstart
#   mel status
#   mel pull
#   mel test
#   mel help

import json, os, subprocess, sys, datetime, shlex, re

CONFIG_DIRNAME = ".mel"
CONFIG_FILENAME = "config.json"

def run(cmd, check=True):
    if isinstance(cmd, str):
        shell = True
    else:
        shell = False
    print(f"‚Üí {' '.join(cmd) if isinstance(cmd,list) else cmd}")
    proc = subprocess.Popen(cmd, shell=shell, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    out_lines = []
    for line in proc.stdout:
        print(line, end="")
        out_lines.append(line)
    rc = proc.wait()
    if check and rc != 0:
        raise subprocess.CalledProcessError(rc, cmd, "".join(out_lines))
    return rc, "".join(out_lines)

def repo_root():
    rc, out = run(["git", "rev-parse", "--show-toplevel"])
    return out.strip()

def current_branch():
    rc, out = run(["git", "rev-parse", "--abbrev-ref", "HEAD"])
    return out.strip()

def has_remote(remote="origin"):
    rc, out = run(["git", "remote"], check=False)
    return remote in out.split()

def guess_main_name():
    for candidate in ["main", "master"]:
        rc, out = run(["git", "ls-remote", "--heads", "origin", candidate], check=False)
        if out.strip():
            return candidate
    for candidate in ["main", "master"]:
        rc, out = run(["git", "branch", "--list", candidate], check=False)
        if out.strip():
            return candidate
    return "main"

def load_config(root):
    path = os.path.join(root, CONFIG_DIRNAME, CONFIG_FILENAME)
    if os.path.exists(path):
        with open(path, "r") as f:
            return json.load(f)
    return {}

def save_config(root, cfg):
    d = os.path.join(root, CONFIG_DIRNAME)
    os.makedirs(d, exist_ok=True)
    path = os.path.join(d, CONFIG_FILENAME)
    with open(path, "w") as f:
        json.dump(cfg, f, indent=2)
    print(f"‚úì Saved mel config at {os.path.relpath(path, root)}")

def fetch_origin():
    if has_remote("origin"):
        run(["git", "fetch", "origin"])
    else:
        print("! No 'origin' remote found. Skipping fetch.")

def commit_all(default_msg):
    run(["git", "add", "-A"])
    rc, out = run(["git", "commit", "-m", default_msg], check=False)
    if rc != 0:
        print("‚Ä¶ Nothing to commit.")

def push_current(set_upstream=True):
    args = ["git", "push"]
    if set_upstream:
        args += ["-u", "origin", "HEAD"]
    run(args, check=True)

def rebase_onto(ref):
    try:
        run(["git", "rebase", ref])
    except subprocess.CalledProcessError:
        print("‚úñ Rebase hit conflicts. Fix files ‚Üí git add -A && git rebase --continue, or git rebase --abort.")
        sys.exit(2)

def merge_ff_only(ref):
    try:
        run(["git", "merge", "--ff-only", ref])
    except subprocess.CalledProcessError:
        print("‚úñ Fast-forward merge not possible. Run 'mel save' then try again.")
        sys.exit(2)

def get_cfg(root):
    cfg = load_config(root)
    if "main" not in cfg:
        cfg["main"] = guess_main_name()
    return cfg

def sanitize_branch_name(raw_name):
    # Lowercase and replace spaces/invalid chars with '-'
    name = raw_name.strip().lower()
    name = re.sub(r"\s+", "-", name)
    # Allow only safe chars for branch names
    name = re.sub(r"[^a-z0-9._\-/]", "-", name)
    # Collapse repeats and trim
    name = re.sub(r"-+", "-", name).strip("-")
    if not name or name.upper() == "HEAD":
        ts = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
        name = f"mel-{ts}"
    return name

def cmd_start(branch_name):
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]

    fetch_origin()
    base_ref = f"origin/{main}" if has_remote("origin") else main
    run(["git", "checkout", "-B", branch_name, base_ref])
    push_current(set_upstream=True)

    cfg["user_branch"] = branch_name
    save_config(root, cfg)
    print(f"‚úì Now on '{branch_name}' (based on {base_ref}).")

def cmd_save():
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]
    cur = current_branch()

    if cur == main:
        print(f"‚úñ You‚Äôre on '{main}'. Run 'mel start <branch>' first.")
        sys.exit(1)

    ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    commit_all(f"mel save @ {ts}")

    fetch_origin()
    base_ref = f"origin/{main}" if has_remote("origin") else main
    rebase_onto(base_ref)

    push_current(set_upstream=False)
    print("‚úì Save complete.")

def cmd_deploy():
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]
    user = cfg.get("user_branch")
    cur = current_branch()
    branch = user or cur

    if branch == main:
        print(f"‚úñ You're on '{main}', deploy only works from a feature branch.")
        sys.exit(1)

    print("\n‚Äî Pre-deploy test run ‚Äî")
    rc = run_tests()
    if rc != 0:
        print("‚úñ Tests failed. Aborting deploy.")
        sys.exit(rc)

    print("‚ö†Ô∏è  Are you sure you want to push everything live?!")
    response = input("Type 'y' to confirm, anything else to abort: ")
    if response.lower() != 'y':
        print("Deploy cancelled.")
        sys.exit(0)

    ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    commit_all(f"mel deploy pre-commit @ {ts}")

    fetch_origin()
    run(["git", "checkout", main])
    if has_remote("origin"):
        run(["git", "pull", "--ff-only", "origin", main])

    merge_ff_only(branch)
    run(["git", "push", "origin", main])

    run(["git", "checkout", branch])
    base_ref = f"origin/{main}" if has_remote("origin") else main
    rebase_onto(base_ref)
    push_current(set_upstream=False)

    print("‚úì Deploy complete.")

def cmd_freshstart():
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]
    branch = current_branch()
    if branch == main:
        print("‚úñ Don‚Äôt run freshstart on main.")
        sys.exit(1)

    fetch_origin()
    base_ref = f"origin/{main}" if has_remote("origin") else main

    print(f"!! This will ERASE all commits on {branch} and reset it to {base_ref}")
    input("Press Enter to confirm, Ctrl+C to abort‚Ä¶")

    run(["git", "reset", "--hard", base_ref])
    run(["git", "push", "--force", "origin", branch])
    print(f"‚úì Branch {branch} reset to {base_ref} and force-pushed.")

def cmd_status():
    root = repo_root()
    cfg = get_cfg(root)
    cur = current_branch()
    rc, porcelain = run(["git", "status", "--porcelain"], check=False)
    dirty_count = len([l for l in porcelain.splitlines() if l.strip()])
    rc, last_commit = run(["git", "log", "-1", "--pretty=%h %s (%cr)"], check=False)
    # ahead/behind (may fail if no upstream)
    ahead = behind = "?"
    rc, ab = run(["git", "rev-list", "--left-right", "--count", "@{u}...HEAD"], check=False)
    try:
        left, right = ab.strip().split()
        behind, ahead = left, right
    except Exception:
        pass

    print("‚Äî mel status ‚Äî")
    print(json.dumps({
        "main": cfg.get("main"),
        "user_branch": cfg.get("user_branch"),
        "current_branch": cur,
        "ahead": ahead,
        "behind": behind,
        "dirty_files": dirty_count,
        "last_commit": last_commit.strip(),
    }, indent=2))
    print("‚Äî git status ‚Äî")
    run(["git", "status", "-sb"])

def cmd_pull():
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]
    cur = current_branch()
    
    # Check for uncommitted changes
    rc, out = run(["git", "status", "--porcelain"], check=False)
    if out.strip():
        print("‚ö†Ô∏è  You have uncommitted changes:")
        print(out)
        print("\nWhat would you like to do?")
        print("1. Save changes (run 'mel save' first)")
        print("2. Remove changes (stash and drop)")
        print("3. Cancel pull")
        
        response = input("Enter 1, 2, or 3: ")
        
        if response == "1":
            print("Running 'mel save' first...")
            cmd_save()
        elif response == "2":
            print("Stashing and removing changes...")
            run(["git", "stash", "push", "-m", "mel pull cleanup"])
            run(["git", "stash", "drop"])
        elif response == "3":
            print("Pull cancelled.")
            sys.exit(0)
        else:
            print("Invalid choice. Pull cancelled.")
            sys.exit(1)
    
    # Now pull the latest changes from main
    fetch_origin()
    base_ref = f"origin/{main}" if has_remote("origin") else main
    
    if cur == main:
        # On main branch, just pull
        if has_remote("origin"):
            run(["git", "pull", "--ff-only", "origin", main])
        print("‚úì Updated main to latest.")
    else:
        # On feature branch, merge latest main into current branch
        print(f"üì• Merging latest {main} into current branch...")
        merge_ff_only(base_ref)
        print("‚úì Updated feature branch with latest main.")

def run_tests():
    root = repo_root()
    cfg = get_cfg(root)
    configured_cmds = cfg.get("test_commands")

    if configured_cmds and isinstance(configured_cmds, list):
        print("\n‚Äî Running configured tests ‚Äî")
        results = []
        for cmd in configured_cmds:
            print(f"\n$ {cmd}")
            rc, _ = run(cmd, check=False)
            results.append((cmd, rc))
        print("\n‚Äî Test Summary ‚Äî")
        for cmd, rc in results:
            print(("‚úì" if rc == 0 else "‚úñ") + f" {cmd}")
        return 0 if all(rc == 0 for _, rc in results) else 1

    # Fallback legacy behavior for older projects
    backend_dir = os.path.join(root, "backend")
    frontend_dir = os.path.join(root, "backend", "frontend")
    any_legacy = False
    backend_rc = 0
    frontend_rc = 0

    if os.path.isdir(backend_dir):
        any_legacy = True
        print("\n‚Äî Running backend tests ‚Äî")
        pytest_path = os.path.join(backend_dir, "venv", "bin", "pytest")
        if not os.path.exists(pytest_path):
            print("! Backend venv not found. Run ./install.sh first.")
            backend_rc = 1
        else:
            backend_rc, _ = run([pytest_path, "-q", "--disable-warnings"], check=False)

    if os.path.isdir(frontend_dir):
        any_legacy = True
        print("\n‚Äî Running frontend tests ‚Äî")
        npm_cmd = f"cd {shlex.quote(frontend_dir)} && npm run test -s"
        frontend_rc, _ = run(npm_cmd, check=False)

    if not any_legacy:
        print("! No test_commands configured and no legacy test setup detected. Skipping tests.")
        return 0

    print("\n‚Äî Test Summary ‚Äî")
    if any_legacy:
        print(("‚úì" if backend_rc == 0 else "‚úñ") + " Backend")
        print(("‚úì" if frontend_rc == 0 else "‚úñ") + " Frontend")
    return 0 if (backend_rc == 0 and frontend_rc == 0) else 1

def cmd_test():
    rc = run_tests()
    sys.exit(rc)

def cmd_help():
    help_text = """
mel ‚Äî a tiny helper for non‚Äëgit folks

Usage:
  mel start [branch]   Create/reset a feature branch from main (prompts if omitted)
  mel save             Commit all, rebase on latest main, push
  mel deploy           Run tests, FF merge branch into main, push, rebase branch
  mel freshstart       Hard reset current feature branch to main and force-push
  mel status           Show summary (ahead/behind, dirty files, last commit) and git status
  mel pull             Update main or FF merge latest main into current branch
  mel test             Run configured test commands from .mel/config.json
  mel help             Show this help

Config (.mel/config.json):
  {
    "main": "main",
    "test_commands": ["npm ci && npm test -s", "pytest -q --disable-warnings"]
  }
"""
    print(help_text.strip())

def main():
    if len(sys.argv) < 2:
        cmd_help()
        sys.exit(0)
    cmd = sys.argv[1]
    if cmd in ("help", "-h", "--help"):
        cmd_help()
    elif cmd == "start":
        if len(sys.argv) >= 3:
            branch = sys.argv[2]
        else:
            print("No branch provided.")
            entered = input("What's your name? We'll create a branch with it: ").strip()
            if not entered:
                print("‚úñ No name provided.")
                sys.exit(1)
            branch = entered
        cmd_start(sanitize_branch_name(branch))
    elif cmd == "save":
        cmd_save()
    elif cmd == "deploy":
        cmd_deploy()
    elif cmd == "freshstart":
        cmd_freshstart()
    elif cmd == "status":
        cmd_status()
    elif cmd == "pull":
        cmd_pull()
    elif cmd == "test":
        cmd_test()
    else:
        print(f"Unknown command: {cmd}")
        sys.exit(1)

if __name__ == "__main__":
    main()