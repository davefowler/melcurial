#!/usr/bin/env python3
# mel — "melcurial" helper for non-engineers
# Commands:
#   mel start [name]
#   mel save
#   mel publish
#   mel reset
#   mel status
#   mel pull | mel update
#   mel help
#   mel sync
#   mel open [repo|branch|pr]
#   mel diff

import json, os, subprocess, sys, datetime, shlex, re, platform

CONFIG_DIRNAME = ".mel"
CONFIG_FILENAME = "config.json"

def run(cmd, check=True, cwd=None, env=None):
    if isinstance(cmd, str):
        shell = True
    else:
        shell = False
    print(f"→ {' '.join(cmd) if isinstance(cmd,list) else cmd}")
    merged_env = os.environ.copy()
    if env:
        merged_env.update({str(k): str(v) for k, v in env.items()})
    proc = subprocess.Popen(cmd, shell=shell, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, cwd=cwd, env=merged_env)
    out_lines = []
    for line in proc.stdout:
        print(line, end="")
        out_lines.append(line)
    rc = proc.wait()
    if check and rc != 0:
        raise subprocess.CalledProcessError(rc, cmd, "".join(out_lines))
    return rc, "".join(out_lines)

def repo_root():
    rc, out = run(["git", "rev-parse", "--show-toplevel"])
    return out.strip()

def current_branch():
    rc, out = run(["git", "rev-parse", "--abbrev-ref", "HEAD"])
    return out.strip()

def has_remote(remote="origin"):
    rc, out = run(["git", "remote"], check=False)
    return remote in out.split()

def guess_main_name():
    for candidate in ["main", "master"]:
        rc, out = run(["git", "ls-remote", "--heads", "origin", candidate], check=False)
        if out.strip():
            return candidate
    for candidate in ["main", "master"]:
        rc, out = run(["git", "branch", "--list", candidate], check=False)
        if out.strip():
            return candidate
    return "main"

def load_config(root):
    path = os.path.join(root, CONFIG_DIRNAME, CONFIG_FILENAME)
    if os.path.exists(path):
        with open(path, "r") as f:
            return json.load(f)
    return {}

def save_config(root, cfg):
    d = os.path.join(root, CONFIG_DIRNAME)
    os.makedirs(d, exist_ok=True)
    path = os.path.join(d, CONFIG_FILENAME)
    with open(path, "w") as f:
        json.dump(cfg, f, indent=2)
    print(f"✓ Saved mel config at {os.path.relpath(path, root)}")
    ensure_mel_gitignored(root)

def fetch_origin():
    if has_remote("origin"):
        run(["git", "fetch", "origin"])
    else:
        print("! No 'origin' remote found. Skipping fetch.")

def commit_all(default_msg):
    run(["git", "add", "-A"])
    rc, out = run(["git", "commit", "-m", default_msg], check=False)
    if rc != 0:
        print("… Nothing to commit.")

def push_current(set_upstream=True):
    args = ["git", "push"]
    if set_upstream:
        args += ["-u", "origin", "HEAD"]
    run(args, check=True)

def rebase_onto(ref):
    try:
        run(["git", "rebase", ref])
    except subprocess.CalledProcessError:
        print("✖ Rebase hit conflicts. Fix files → git add -A && git rebase --continue, or git rebase --abort.")
        sys.exit(2)

def merge_ff_only(ref):
    try:
        run(["git", "merge", "--ff-only", ref])
    except subprocess.CalledProcessError:
        print("✖ Fast-forward merge not possible. Run 'mel save' then try again.")
        sys.exit(2)

def get_cfg(root):
    cfg_path = os.path.join(root, CONFIG_DIRNAME, CONFIG_FILENAME)
    cfg = load_config(root)
    if not cfg and not os.path.exists(cfg_path):
        # Attempt to import from template if provided
        tpl = load_template_config(root)
        if tpl:
            cfg = tpl
            save_config(root, cfg)
            print("✓ Imported mel config from template")
    if "main" not in cfg:
        cfg["main"] = guess_main_name()
    if "update_strategy" not in cfg:
        cfg["update_strategy"] = "rebase"  # or "merge"
    if "scripts" not in cfg:
        cfg["scripts"] = {}
    if "allow_package_scripts" not in cfg:
        cfg["allow_package_scripts"] = True
    if "require_publish_confirmation" not in cfg:
        cfg["require_publish_confirmation"] = True
    return cfg

def sanitize_branch_name(raw_name):
    # Lowercase and replace spaces/invalid chars with '-'
    name = raw_name.strip().lower()
    name = re.sub(r"\s+", "-", name)
    # Allow only safe chars for branch names
    name = re.sub(r"[^a-z0-9._\-/]", "-", name)
    # Collapse repeats and trim
    name = re.sub(r"-+", "-", name).strip("-")
    if not name or name.upper() == "HEAD":
        ts = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
        name = f"mel-{ts}"
    return name

def open_url(url):
    system = platform.system().lower()
    if system == "darwin":
        run(["open", url], check=False)
    elif system == "windows":
        run(["cmd", "/c", "start", url], check=False)
    else:
        run(["xdg-open", url], check=False)

def get_origin_web_url():
    rc, url = run(["git", "remote", "get-url", "origin"], check=False)
    u = url.strip()
    if not u:
        return None
    m = re.match(r"git@([^:]+):([^/]+)/([^/]+)(\\.git)?$", u)
    if m:
        host, owner, repo = m.group(1), m.group(2), m.group(3)
        if repo.endswith(".git"):
            repo = repo[:-4]
        return f"https://{host}/{owner}/{repo}"
    m = re.match(r"https?://([^/]+)/([^/]+)/([^/]+)(\\.git)?/?$", u)
    if m:
        host, owner, repo = m.group(1), m.group(2), m.group(3)
        if repo.endswith(".git"):
            repo = repo[:-4]
        return f"https://{host}/{owner}/{repo}"
    return None

def ensure_mel_gitignored(root):
    gi_path = os.path.join(root, ".gitignore")
    if not os.path.exists(gi_path):
        return
    try:
        with open(gi_path, "r", encoding="utf-8") as f:
            lines = f.read().splitlines()
    except Exception:
        return
    normalized = [l.strip() for l in lines]
    if ".mel" in normalized or ".mel/" in normalized:
        return
    # Append an entry to ignore the mel config directory
    needs_newline = (len(lines) > 0 and not lines[-1].endswith("\n"))
    to_append = ("\n" if needs_newline else "") + ".mel/\n"
    with open(gi_path, "a", encoding="utf-8") as f:
        f.write(to_append)
    print("✓ Ensured .mel/ is ignored via .gitignore")

def load_template_config(root):
    # Repo-local templates
    candidates = [
        os.path.join(root, CONFIG_DIRNAME, "config_template.json"),
        os.path.join(root, CONFIG_DIRNAME, "config.template.json"),
    ]
    # Global template
    home = os.path.expanduser("~")
    candidates.append(os.path.join(home, ".mel", "config_template.json"))
    candidates.append(os.path.join(home, ".mel", "config.template.json"))

    for p in candidates:
        try:
            if os.path.exists(p):
                with open(p, "r", encoding="utf-8") as f:
                    return json.load(f)
        except Exception:
            continue
    return None

def load_package_scripts(root):
    pkg_path = os.path.join(root, "package.json")
    if not os.path.exists(pkg_path):
        return {}
    try:
        with open(pkg_path, "r", encoding="utf-8") as f:
            pkg = json.load(f)
        scripts = pkg.get("scripts") or {}
        if not isinstance(scripts, dict):
            return {}
        return {k: v for k, v in scripts.items() if isinstance(v, str)}
    except Exception:
        return {}

def get_current_author():
    rc, name = run(["git", "config", "user.name"], check=False)
    return name.strip() or ""

def format_merge_message(cfg, context, branch, main):
    template = None
    if context == "sync":
        template = cfg.get("merge_message_after_sync") or cfg.get("merge_message")
    else:
        template = cfg.get("merge_message")
    if not template:
        return None
    now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    author = get_current_author()
    return template.format(branch=branch, main=main, author=author, datetime=now)

def run_hooks(cfg, hook_key):
    hooks = cfg.get(hook_key)
    if not hooks:
        return
    if not isinstance(hooks, list):
        print(f"! Ignoring invalid hook list for {hook_key}; expected list.")
        return
    for item in hooks:
        if isinstance(item, str):
            # Treat as a script name first, else raw command
            if item in (cfg.get("scripts") or {}):
                rc = run_script_by_name(cfg, item, extra_args=[])
                if rc != 0:
                    raise subprocess.CalledProcessError(rc, item)
            else:
                rc, _ = run(item, check=False)
                if rc != 0:
                    raise subprocess.CalledProcessError(rc, item)
        elif isinstance(item, dict):
            # Inline command object
            cmd = item.get("cmd")
            if not cmd:
                continue
            cwd = item.get("cwd")
            env = item.get("env")
            rc, _ = run(cmd, check=False, cwd=cwd, env=env)
            if rc != 0:
                raise subprocess.CalledProcessError(rc, cmd)
        else:
            print(f"! Unsupported hook entry type: {type(item)}")

def detect_package_manager(root):
    if os.path.exists(os.path.join(root, 'pnpm-lock.yaml')):
        return 'pnpm'
    if os.path.exists(os.path.join(root, 'yarn.lock')):
        return 'yarn'
    return 'npm'

def run_script_by_name(cfg, name, extra_args):
    root = repo_root()
    scripts = cfg.get("scripts") or {}
    entry = scripts.get(name)
    if entry is None and cfg.get("allow_package_scripts"):
        pm = detect_package_manager(root)
        args = " ".join(shlex.quote(a) for a in extra_args) if extra_args else ""
        cmd = f"{pm} run {shlex.quote(name)}" + (f" -- {args}" if args else "")
        rc, _ = run(cmd, check=False)
        return rc

    if entry is None:
        print(f"✖ Script '{name}' not found.")
        return 1

    if isinstance(entry, str):
        cmd = entry
        if extra_args:
            cmd = cmd + " " + " ".join(shlex.quote(a) for a in extra_args)
        rc, _ = run(cmd, check=False)
        return rc
    elif isinstance(entry, dict):
        cmd = entry.get("cmd")
        if not cmd:
            print(f"✖ Script '{name}' is missing 'cmd'.")
            return 1
        if extra_args:
            cmd = cmd + " " + " ".join(shlex.quote(a) for a in extra_args)
        cwd = entry.get("cwd")
        env = entry.get("env")
        rc, _ = run(cmd, check=False, cwd=cwd, env=env)
        return rc
    else:
        print(f"✖ Script '{name}' has an unsupported format.")
        return 1

def cmd_start(branch_name):
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]

    fetch_origin()
    base_ref = f"origin/{main}" if has_remote("origin") else main
    run(["git", "checkout", "-B", branch_name, base_ref])
    push_current(set_upstream=True)

    cfg["user_branch"] = branch_name
    save_config(root, cfg)
    print(f"✓ Now on '{branch_name}' (based on {base_ref}).")

def cmd_save():
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]
    cur = current_branch()

    if cur == main:
        print(f"✖ You’re on '{main}'. Run 'mel start <branch>' first.")
        sys.exit(1)

    ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    # pre-save hooks
    try:
        run_hooks(cfg, "pre_save")
    except subprocess.CalledProcessError:
        print("✖ pre_save hook failed. Aborting.")
        sys.exit(1)
    commit_all(f"mel save @ {ts}")

    fetch_origin()
    base_ref = f"origin/{main}" if has_remote("origin") else main
    rebase_onto(base_ref)

    push_current(set_upstream=False)
    try:
        run_hooks(cfg, "post_save")
    except subprocess.CalledProcessError:
        print("✖ post_save hook failed.")
    print("✓ Save complete.")

def cmd_deploy():
    # Back-compat alias for publish
    return cmd_publish()

def cmd_publish():
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]
    user = cfg.get("user_branch")
    cur = current_branch()
    branch = user or cur

    if branch == main:
        print(f"✖ You're on '{main}', publish only works from a feature branch.")
        sys.exit(1)

    print("\n— Pre-publish test run —")
    try:
        run_hooks(cfg, "pre_publish")
    except subprocess.CalledProcessError:
        print("✖ pre_publish hook failed. Aborting.")
        sys.exit(1)
    rc = run_tests()
    if rc != 0:
        print("✖ Tests failed. Aborting publish.")
        sys.exit(rc)

    yes_mode = (os.environ.get("MEL_YES") == "1" or "--yes" in sys.argv)
    if not yes_mode and cfg.get("require_publish_confirmation", True):
        print("⚠️  Are you sure you want to push everything live?!")
        response = input("Type 'y' to confirm, anything else to abort: ")
        if response.lower() != 'y':
            print("Publish cancelled.")
            sys.exit(0)

    ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    commit_all(f"mel publish pre-commit @ {ts}")

    fetch_origin()
    run(["git", "checkout", main])
    if has_remote("origin"):
        run(["git", "pull", "--ff-only", "origin", main])

    merge_ff_only(branch)
    run(["git", "push", "origin", main])

    run(["git", "checkout", branch])
    base_ref = f"origin/{main}" if has_remote("origin") else main
    rebase_onto(base_ref)
    push_current(set_upstream=False)

    try:
        run_hooks(cfg, "post_publish")
    except subprocess.CalledProcessError:
        print("✖ post_publish hook failed.")
    print("✓ Publish complete.")

def cmd_freshstart():
    # Back-compat alias; route to reset
    return cmd_reset()

def cmd_reset():
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]
    branch = current_branch()
    if branch == main:
        print("✖ Don’t run reset on main.")
        sys.exit(1)

    fetch_origin()
    base_ref = f"origin/{main}" if has_remote("origin") else main

    print(f"!! This will ERASE all commits on {branch} and reset it to {base_ref}")
    yes_mode = (os.environ.get("MEL_YES") == "1" or "--yes" in sys.argv)
    if not yes_mode:
        input("Press Enter to confirm, Ctrl+C to abort…")

    run(["git", "reset", "--hard", base_ref])
    run(["git", "push", "--force", "origin", branch])
    print(f"✓ Branch {branch} reset to {base_ref} and force-pushed.")

def cmd_status():
    root = repo_root()
    cfg = get_cfg(root)
    cur = current_branch()
    rc, porcelain = run(["git", "status", "--porcelain"], check=False)
    dirty_count = len([l for l in porcelain.splitlines() if l.strip()])
    rc, last_commit = run(["git", "log", "-1", "--pretty=%h %s (%cr)"], check=False)
    # ahead/behind (may fail if no upstream)
    ahead = behind = "?"
    upstream = None
    rc, upstream_out = run(["git", "rev-parse", "--abbrev-ref", "--symbolic-full-name", "@{u}"], check=False)
    if rc == 0:
        upstream = upstream_out.strip()
    rc, ab = run(["git", "rev-list", "--left-right", "--count", "@{u}...HEAD"], check=False)
    try:
        left, right = ab.strip().split()
        behind, ahead = left, right
    except Exception:
        pass

    print("— mel status —")
    status_obj = {
        "main": cfg.get("main"),
        "user_branch": cfg.get("user_branch"),
        "current_branch": cur,
        "ahead": ahead,
        "behind": behind,
        "dirty_files": dirty_count,
        "last_commit": last_commit.strip(),
    }
    if not upstream:
        status_obj["upstream"] = None
        status_obj["set_upstream_hint"] = "git push -u origin HEAD"
    else:
        status_obj["upstream"] = upstream
    print(json.dumps(status_obj, indent=2))
    print("— git status —")
    run(["git", "status", "-sb"])

def cmd_pull():
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]
    cur = current_branch()
    
    # Check for uncommitted changes and offer save/stash
    rc, out = run(["git", "status", "--porcelain"], check=False)
    stashed = False
    if out.strip():
        print("⚠️  You have uncommitted changes:")
        print(out)
        print("\nWhat would you like to do?")
        print("1. Save changes (commit now)")
        print("2. Stash and re-apply after update")
        print("3. Cancel pull")
        response = input("Enter 1, 2, or 3: ")
        if response == "1":
            ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
            commit_all(f"mel save @ {ts}")
        elif response == "2":
            print("Stashing and will re-apply after update...")
            run(["git", "stash", "push", "-m", "mel pull temp"])
            stashed = True
        elif response == "3":
            print("Pull cancelled.")
            sys.exit(0)
        else:
            print("Invalid choice. Pull cancelled.")
            sys.exit(1)
    
    # Now pull the latest changes from main
    fetch_origin()
    base_ref = f"origin/{main}" if has_remote("origin") else main
    
    if cur == main:
        # On main branch, just pull
        if has_remote("origin"):
            run(["git", "pull", "--ff-only", "origin", main])
        print("✓ Updated main to latest.")
    else:
        # On feature branch, update with latest main via configured strategy
        strategy = (cfg.get("update_strategy") or "rebase").lower()
        print(f"📥 Updating current branch with latest {main} via {strategy}...")
        if strategy == "merge":
            msg = format_merge_message(cfg, "update", cur, main)
            try:
                if msg:
                    run(["git", "merge", "--no-edit", "-m", msg, base_ref])
                else:
                    run(["git", "merge", base_ref])
            except subprocess.CalledProcessError:
                print("✖ Merge hit conflicts. Fix files → git add -A && git merge --continue, or git merge --abort.")
                sys.exit(2)
        else:
            rebase_onto(base_ref)
        if stashed:
            print("Re-applying stashed changes...")
            rc, _ = run(["git", "stash", "pop"], check=False)
            if rc != 0:
                print("⚠️  Conflicts may have occurred while applying stashed changes. Resolve and continue.")
        print("✓ Updated feature branch with latest main.")

def run_tests():
    root = repo_root()
    cfg = get_cfg(root)
    scripts = cfg.get("scripts") or {}
    if "test" not in scripts and not cfg.get("allow_package_scripts"):
        print("! No 'test' script configured. Skipping tests.")
        return 0
    rc = run_script_by_name(cfg, "test", extra_args=[])
    return 0 if rc == 0 else 1

def cmd_test():
    rc = run_tests()
    sys.exit(rc)

def cmd_update():
    cmd_pull()

def cmd_diff():
    print("— Diff (staged) —")
    run(["git", "diff", "--staged", "--stat"], check=False)
    print("\n— Diff (unstaged) —")
    run(["git", "diff", "--stat"], check=False)

def cmd_open(target=None):
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]
    base = get_origin_web_url()
    if not base:
        print("! Cannot determine origin URL.")
        sys.exit(1)
    cur = current_branch()
    if not target or target == "repo":
        url = base
    elif target == "branch":
        if "github.com" in base:
            url = f"{base}/tree/{cur}"
        else:
            url = base
    elif target == "pr":
        if "github.com" in base:
            url = f"{base}/compare/{main}...{cur}?expand=1"
        else:
            url = base
    else:
        print(f"Unknown open target: {target}")
        sys.exit(1)
    print(f"→ Opening {url}")
    open_url(url)

def ensure_clean_or_handle(non_interactive=False):
    rc, out = run(["git", "status", "--porcelain"], check=False)
    if not out.strip():
        return "clean"
    print("⚠️  You have uncommitted changes:")
    print(out)
    if non_interactive:
        print("--yes provided. Defaulting to 'Save changes'.")
        return "save"
    print("\nWhat would you like to do?")
    print("1. Save changes (commit now)")
    print("2. Stash and re-apply after update")
    print("3. Cancel")
    response = input("Enter 1, 2, or 3: ")
    if response == "1":
        return "save"
    elif response == "2":
        return "stash"
    elif response == "3":
        print("Cancelled.")
        sys.exit(0)
    else:
        print("Invalid choice. Cancelled.")
        sys.exit(1)

def cmd_sync(non_interactive=False):
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]
    cur = current_branch()

    if cur == main:
        print(f"✖ You’re on '{main}'. Run 'mel start [name]' first.")
        sys.exit(1)

    action = ensure_clean_or_handle(non_interactive=non_interactive)
    stashed = False
    if action == "save":
        ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
        commit_all(f"mel save @ {ts}")
    elif action == "stash":
        print("Stashing changes for sync...")
        run(["git", "stash", "push", "-m", "mel sync temp"])
        stashed = True

    fetch_origin()
    base_ref = f"origin/{main}" if has_remote("origin") else main

    strategy = (cfg.get("update_strategy") or "rebase").lower()
    print(f"🔄 Sync: updating {cur} with latest {main} via {strategy}...")
    if strategy == "merge":
        msg = format_merge_message(cfg, "sync", cur, main)
        try:
            if msg:
                run(["git", "merge", "--no-edit", "-m", msg, base_ref])
            else:
                run(["git", "merge", base_ref])
        except subprocess.CalledProcessError:
            print("✖ Merge hit conflicts. Fix files → git add -A && git merge --continue, or git merge --abort.")
            sys.exit(2)
    else:
        rebase_onto(base_ref)

    if stashed:
        print("Re-applying stashed changes...")
        rc, _ = run(["git", "stash", "pop"], check=False)
        if rc != 0:
            print("⚠️  Conflicts may have occurred while applying stashed changes. Resolve, then 'git add -A' and continue.")

    push_current(set_upstream=False)

    base = get_origin_web_url()
    if base and cfg.get("open_pr_on_sync"):
        if "github.com" in base:
            pr_url = f"{base}/compare/{main}...{cur}?expand=1"
            print(f"→ Opening PR: {pr_url}")
            open_url(pr_url)
        else:
            print("! open_pr_on_sync configured, but could not determine PR URL for this remote.")
    print("✓ Sync complete.")

def cmd_help():
    root = repo_root()
    cfg = get_cfg(root)
    configured = cfg.get("scripts") or {}
    package = load_package_scripts(root) if cfg.get("allow_package_scripts") else {}
    
    scripts_section = ""
    if configured or package:
        scripts_section = "\nScripts:\n"
        if configured:
            for k, v in configured.items():
                if isinstance(v, str):
                    scripts_section += f"  mel run {k}        {v}\n"
                elif isinstance(v, dict):
                    scripts_section += f"  mel run {k}        {v.get('cmd','')}\n"
        if package:
            for k, v in sorted(package.items()):
                scripts_section += f"  mel run {k}        {v}\n"

    help_text = """
mel — a tiny helper for non‑engineers

Basic commands:
  mel start [name]     Create/reset a feature branch from main (prompts if omitted)
  mel save             Commit all, update with main, push
  mel sync             Save/stash as needed, update with main (rebase by default), push
  mel publish          Run tests, FF merge branch into main, push, rebase branch (--yes to skip confirm)
  mel status           Show summary (ahead/behind, dirty files, last commit) and git status
  mel update           Get the updates that others have deployed
  mel test             Run your project's test script

Advanced commands:
  mel diff             Show staged and unstaged diff stats
  mel open [repo|branch|pr]  Open remote in browser
  mel reset            Hard reset current feature branch to main and force-push
  mel run <name> [-- args...]  Run a configured script by name
  mel help             Show this help

Docs: https://davefowler.github.io/melcurial/
""" + scripts_section
    print(help_text.strip())

def main():
    if len(sys.argv) < 2:
        cmd_help()
        sys.exit(0)
    yes_mode = (os.environ.get("MEL_YES") == "1" or "--yes" in sys.argv)
    args = [a for a in sys.argv[1:] if a != "--yes"]
    cmd = args[0]
    if cmd in ("help", "-h", "--help"):
        cmd_help()
    elif cmd == "start":
        if len(args) >= 2:
            branch = args[1]
        else:
            print("No branch provided.")
            entered = input("What's your name? We'll create a branch with it: ").strip()
            if not entered:
                print("✖ No name provided.")
                sys.exit(1)
            branch = entered
        cmd_start(sanitize_branch_name(branch))
    elif cmd == "save":
        cmd_save()
    elif cmd == "deploy":
        cmd_deploy()
    elif cmd == "publish":
        cmd_publish()
    elif cmd == "freshstart":
        cmd_freshstart()
    elif cmd == "reset":
        cmd_reset()
    elif cmd == "status":
        cmd_status()
    elif cmd == "pull":
        cmd_pull()
    elif cmd == "update":
        cmd_update()
    elif cmd == "test":
        cmd_test()
    elif cmd == "sync":
        cmd_sync(non_interactive=yes_mode)
    elif cmd == "open":
        target = args[1] if len(args) >= 2 else None
        cmd_open(target)
    elif cmd == "diff":
        cmd_diff()
    elif cmd == "scripts":
        root = repo_root()
        cfg = get_cfg(root)
        configured = cfg.get("scripts") or {}
        package = load_package_scripts(root) if cfg.get("allow_package_scripts") else {}
        printed = False
        if configured:
            print("— Configured scripts (.mel/config.json) —")
            for k, v in configured.items():
                if isinstance(v, str):
                    print(f"{k}: {v}")
                elif isinstance(v, dict):
                    print(f"{k}: {v.get('cmd','')}")
                else:
                    print(f"{k}: (unsupported)")
            printed = True
        if package:
            if printed:
                print()
            print("— Package scripts (package.json) —")
            for k, v in sorted(package.items()):
                print(f"{k}: {v}")
            printed = True
        if not printed:
            print("(no scripts available)")
    elif cmd == "run":
        if len(args) < 2:
            print("Usage: mel run <name> [-- args...]")
            sys.exit(1)
        name = args[1]
        # find `--` to split extra args
        extra = []
        if "--" in args:
            idx = args.index("--")
            extra = args[idx+1:]
        cfg = get_cfg(repo_root())
        rc = run_script_by_name(cfg, name, extra)
        sys.exit(rc)
    else:
        print(f"Unknown command: {cmd}")
        sys.exit(1)

if __name__ == "__main__":
    main()