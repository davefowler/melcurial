#!/usr/bin/env python3
# mel — "melcurial" helper for non-engineers
# Commands:
#   mel start [name]
#   mel save
#   mel publish
#   mel reset
#   mel status
#   mel pull | mel update
#   mel test
#   mel help
#   mel sync
#   mel open [repo|branch|pr]
#   mel diff

import json, os, subprocess, sys, datetime, shlex, re, platform

CONFIG_DIRNAME = ".mel"
CONFIG_FILENAME = "config.json"

def run(cmd, check=True):
    if isinstance(cmd, str):
        shell = True
    else:
        shell = False
    print(f"→ {' '.join(cmd) if isinstance(cmd,list) else cmd}")
    proc = subprocess.Popen(cmd, shell=shell, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    out_lines = []
    for line in proc.stdout:
        print(line, end="")
        out_lines.append(line)
    rc = proc.wait()
    if check and rc != 0:
        raise subprocess.CalledProcessError(rc, cmd, "".join(out_lines))
    return rc, "".join(out_lines)

def repo_root():
    rc, out = run(["git", "rev-parse", "--show-toplevel"])
    return out.strip()

def current_branch():
    rc, out = run(["git", "rev-parse", "--abbrev-ref", "HEAD"])
    return out.strip()

def has_remote(remote="origin"):
    rc, out = run(["git", "remote"], check=False)
    return remote in out.split()

def guess_main_name():
    for candidate in ["main", "master"]:
        rc, out = run(["git", "ls-remote", "--heads", "origin", candidate], check=False)
        if out.strip():
            return candidate
    for candidate in ["main", "master"]:
        rc, out = run(["git", "branch", "--list", candidate], check=False)
        if out.strip():
            return candidate
    return "main"

def load_config(root):
    path = os.path.join(root, CONFIG_DIRNAME, CONFIG_FILENAME)
    if os.path.exists(path):
        with open(path, "r") as f:
            return json.load(f)
    return {}

def save_config(root, cfg):
    d = os.path.join(root, CONFIG_DIRNAME)
    os.makedirs(d, exist_ok=True)
    path = os.path.join(d, CONFIG_FILENAME)
    with open(path, "w") as f:
        json.dump(cfg, f, indent=2)
    print(f"✓ Saved mel config at {os.path.relpath(path, root)}")

def fetch_origin():
    if has_remote("origin"):
        run(["git", "fetch", "origin"])
    else:
        print("! No 'origin' remote found. Skipping fetch.")

def commit_all(default_msg):
    run(["git", "add", "-A"])
    rc, out = run(["git", "commit", "-m", default_msg], check=False)
    if rc != 0:
        print("… Nothing to commit.")

def push_current(set_upstream=True):
    args = ["git", "push"]
    if set_upstream:
        args += ["-u", "origin", "HEAD"]
    run(args, check=True)

def rebase_onto(ref):
    try:
        run(["git", "rebase", ref])
    except subprocess.CalledProcessError:
        print("✖ Rebase hit conflicts. Fix files → git add -A && git rebase --continue, or git rebase --abort.")
        sys.exit(2)

def merge_ff_only(ref):
    try:
        run(["git", "merge", "--ff-only", ref])
    except subprocess.CalledProcessError:
        print("✖ Fast-forward merge not possible. Run 'mel save' then try again.")
        sys.exit(2)

def get_cfg(root):
    cfg = load_config(root)
    if "main" not in cfg:
        cfg["main"] = guess_main_name()
    if "update_strategy" not in cfg:
        cfg["update_strategy"] = "rebase"  # or "merge"
    if "example_test_commands" not in cfg and "test_commands" not in cfg:
        cfg["example_test_commands"] = [
            "npm ci && npm test -s",
            "pytest -q --disable-warnings"
        ]
    return cfg

def sanitize_branch_name(raw_name):
    # Lowercase and replace spaces/invalid chars with '-'
    name = raw_name.strip().lower()
    name = re.sub(r"\s+", "-", name)
    # Allow only safe chars for branch names
    name = re.sub(r"[^a-z0-9._\-/]", "-", name)
    # Collapse repeats and trim
    name = re.sub(r"-+", "-", name).strip("-")
    if not name or name.upper() == "HEAD":
        ts = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
        name = f"mel-{ts}"
    return name

def open_url(url):
    system = platform.system().lower()
    if system == "darwin":
        run(["open", url], check=False)
    elif system == "windows":
        run(["cmd", "/c", "start", url], check=False)
    else:
        run(["xdg-open", url], check=False)

def get_origin_web_url():
    rc, url = run(["git", "remote", "get-url", "origin"], check=False)
    u = url.strip()
    if not u:
        return None
    m = re.match(r"git@([^:]+):([^/]+)/([^/]+)(\\.git)?$", u)
    if m:
        host, owner, repo = m.group(1), m.group(2), m.group(3)
        return f"https://{host}/{owner}/{repo}"
    m = re.match(r"https?://([^/]+)/([^/]+)/([^/]+)(\\.git)?/?$", u)
    if m:
        host, owner, repo = m.group(1), m.group(2), m.group(3)
        return f"https://{host}/{owner}/{repo}"
    return None

def get_current_author():
    rc, name = run(["git", "config", "user.name"], check=False)
    return name.strip() or ""

def format_merge_message(cfg, context, branch, main):
    template = None
    if context == "sync":
        template = cfg.get("merge_message_after_sync") or cfg.get("merge_message")
    else:
        template = cfg.get("merge_message")
    if not template:
        return None
    now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    author = get_current_author()
    return template.format(branch=branch, main=main, author=author, datetime=now)

def cmd_start(branch_name):
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]

    fetch_origin()
    base_ref = f"origin/{main}" if has_remote("origin") else main
    run(["git", "checkout", "-B", branch_name, base_ref])
    push_current(set_upstream=True)

    cfg["user_branch"] = branch_name
    save_config(root, cfg)
    print(f"✓ Now on '{branch_name}' (based on {base_ref}).")

def cmd_save():
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]
    cur = current_branch()

    if cur == main:
        print(f"✖ You’re on '{main}'. Run 'mel start <branch>' first.")
        sys.exit(1)

    ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    commit_all(f"mel save @ {ts}")

    fetch_origin()
    base_ref = f"origin/{main}" if has_remote("origin") else main
    rebase_onto(base_ref)

    push_current(set_upstream=False)
    print("✓ Save complete.")

def cmd_deploy():
    # Back-compat alias for publish
    return cmd_publish()

def cmd_publish():
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]
    user = cfg.get("user_branch")
    cur = current_branch()
    branch = user or cur

    if branch == main:
        print(f"✖ You're on '{main}', publish only works from a feature branch.")
        sys.exit(1)

    print("\n— Pre-publish test run —")
    rc = run_tests()
    if rc != 0:
        print("✖ Tests failed. Aborting publish.")
        sys.exit(rc)

    yes_mode = (os.environ.get("MEL_YES") == "1" or "--yes" in sys.argv)
    if not yes_mode:
        print("⚠️  Are you sure you want to push everything live?!")
        response = input("Type 'y' to confirm, anything else to abort: ")
        if response.lower() != 'y':
            print("Publish cancelled.")
            sys.exit(0)

    ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    commit_all(f"mel publish pre-commit @ {ts}")

    fetch_origin()
    run(["git", "checkout", main])
    if has_remote("origin"):
        run(["git", "pull", "--ff-only", "origin", main])

    merge_ff_only(branch)
    run(["git", "push", "origin", main])

    run(["git", "checkout", branch])
    base_ref = f"origin/{main}" if has_remote("origin") else main
    rebase_onto(base_ref)
    push_current(set_upstream=False)

    print("✓ Publish complete.")

def cmd_freshstart():
    # Back-compat alias; route to reset
    return cmd_reset()

def cmd_reset():
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]
    branch = current_branch()
    if branch == main:
        print("✖ Don’t run reset on main.")
        sys.exit(1)

    fetch_origin()
    base_ref = f"origin/{main}" if has_remote("origin") else main

    print(f"!! This will ERASE all commits on {branch} and reset it to {base_ref}")
    yes_mode = (os.environ.get("MEL_YES") == "1" or "--yes" in sys.argv)
    if not yes_mode:
        input("Press Enter to confirm, Ctrl+C to abort…")

    run(["git", "reset", "--hard", base_ref])
    run(["git", "push", "--force", "origin", branch])
    print(f"✓ Branch {branch} reset to {base_ref} and force-pushed.")

def cmd_status():
    root = repo_root()
    cfg = get_cfg(root)
    cur = current_branch()
    rc, porcelain = run(["git", "status", "--porcelain"], check=False)
    dirty_count = len([l for l in porcelain.splitlines() if l.strip()])
    rc, last_commit = run(["git", "log", "-1", "--pretty=%h %s (%cr)"], check=False)
    # ahead/behind (may fail if no upstream)
    ahead = behind = "?"
    upstream = None
    rc, upstream_out = run(["git", "rev-parse", "--abbrev-ref", "--symbolic-full-name", "@{u}"], check=False)
    if rc == 0:
        upstream = upstream_out.strip()
    rc, ab = run(["git", "rev-list", "--left-right", "--count", "@{u}...HEAD"], check=False)
    try:
        left, right = ab.strip().split()
        behind, ahead = left, right
    except Exception:
        pass

    print("— mel status —")
    status_obj = {
        "main": cfg.get("main"),
        "user_branch": cfg.get("user_branch"),
        "current_branch": cur,
        "ahead": ahead,
        "behind": behind,
        "dirty_files": dirty_count,
        "last_commit": last_commit.strip(),
    }
    if not upstream:
        status_obj["upstream"] = None
        status_obj["set_upstream_hint"] = "git push -u origin HEAD"
    else:
        status_obj["upstream"] = upstream
    print(json.dumps(status_obj, indent=2))
    print("— git status —")
    run(["git", "status", "-sb"])

def cmd_pull():
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]
    cur = current_branch()
    
    # Check for uncommitted changes and offer save/stash
    rc, out = run(["git", "status", "--porcelain"], check=False)
    stashed = False
    if out.strip():
        print("⚠️  You have uncommitted changes:")
        print(out)
        print("\nWhat would you like to do?")
        print("1. Save changes (commit now)")
        print("2. Stash and re-apply after update")
        print("3. Cancel pull")
        response = input("Enter 1, 2, or 3: ")
        if response == "1":
            ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
            commit_all(f"mel save @ {ts}")
        elif response == "2":
            print("Stashing and will re-apply after update...")
            run(["git", "stash", "push", "-m", "mel pull temp"])
            stashed = True
        elif response == "3":
            print("Pull cancelled.")
            sys.exit(0)
        else:
            print("Invalid choice. Pull cancelled.")
            sys.exit(1)
    
    # Now pull the latest changes from main
    fetch_origin()
    base_ref = f"origin/{main}" if has_remote("origin") else main
    
    if cur == main:
        # On main branch, just pull
        if has_remote("origin"):
            run(["git", "pull", "--ff-only", "origin", main])
        print("✓ Updated main to latest.")
    else:
        # On feature branch, update with latest main via configured strategy
        strategy = (cfg.get("update_strategy") or "rebase").lower()
        print(f"📥 Updating current branch with latest {main} via {strategy}...")
        if strategy == "merge":
            msg = format_merge_message(cfg, "update", cur, main)
            try:
                if msg:
                    run(["git", "merge", "--no-edit", "-m", msg, base_ref])
                else:
                    run(["git", "merge", base_ref])
            except subprocess.CalledProcessError:
                print("✖ Merge hit conflicts. Fix files → git add -A && git merge --continue, or git merge --abort.")
                sys.exit(2)
        else:
            rebase_onto(base_ref)
        if stashed:
            print("Re-applying stashed changes...")
            rc, _ = run(["git", "stash", "pop"], check=False)
            if rc != 0:
                print("⚠️  Conflicts may have occurred while applying stashed changes. Resolve and continue.")
        print("✓ Updated feature branch with latest main.")

def run_tests():
    root = repo_root()
    cfg = get_cfg(root)
    configured_cmds = cfg.get("test_commands")

    if configured_cmds and isinstance(configured_cmds, list):
        print("\n— Running configured tests —")
        results = []
        for cmd in configured_cmds:
            print(f"\n$ {cmd}")
            rc, _ = run(cmd, check=False)
            results.append((cmd, rc))
        print("\n— Test Summary —")
        for cmd, rc in results:
            print(("✓" if rc == 0 else "✖") + f" {cmd}")
        return 0 if all(rc == 0 for _, rc in results) else 1

    # Fallback legacy behavior for older projects
    backend_dir = os.path.join(root, "backend")
    frontend_dir = os.path.join(root, "backend", "frontend")
    any_legacy = False
    backend_rc = 0
    frontend_rc = 0

    if os.path.isdir(backend_dir):
        any_legacy = True
        print("\n— Running backend tests —")
        pytest_path = os.path.join(backend_dir, "venv", "bin", "pytest")
        if not os.path.exists(pytest_path):
            print("! Backend venv not found. Run ./install.sh first.")
            backend_rc = 1
        else:
            backend_rc, _ = run([pytest_path, "-q", "--disable-warnings"], check=False)

    if os.path.isdir(frontend_dir):
        any_legacy = True
        print("\n— Running frontend tests —")
        npm_cmd = f"cd {shlex.quote(frontend_dir)} && npm run test -s"
        frontend_rc, _ = run(npm_cmd, check=False)

    if not any_legacy:
        print("! No test_commands configured and no legacy test setup detected. Skipping tests.")
        return 0

    print("\n— Test Summary —")
    if any_legacy:
        print(("✓" if backend_rc == 0 else "✖") + " Backend")
        print(("✓" if frontend_rc == 0 else "✖") + " Frontend")
    return 0 if (backend_rc == 0 and frontend_rc == 0) else 1

def cmd_test():
    rc = run_tests()
    sys.exit(rc)

def cmd_update():
    cmd_pull()

def cmd_diff():
    print("— Diff (staged) —")
    run(["git", "diff", "--staged", "--stat"], check=False)
    print("\n— Diff (unstaged) —")
    run(["git", "diff", "--stat"], check=False)

def cmd_open(target=None):
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]
    base = get_origin_web_url()
    if not base:
        print("! Cannot determine origin URL.")
        sys.exit(1)
    cur = current_branch()
    if not target or target == "repo":
        url = base
    elif target == "branch":
        if "github.com" in base:
            url = f"{base}/tree/{cur}"
        else:
            url = base
    elif target == "pr":
        if "github.com" in base:
            url = f"{base}/compare/{main}...{cur}?expand=1"
        else:
            url = base
    else:
        print(f"Unknown open target: {target}")
        sys.exit(1)
    print(f"→ Opening {url}")
    open_url(url)

def ensure_clean_or_handle(non_interactive=False):
    rc, out = run(["git", "status", "--porcelain"], check=False)
    if not out.strip():
        return "clean"
    print("⚠️  You have uncommitted changes:")
    print(out)
    if non_interactive:
        print("--yes provided. Defaulting to 'Save changes'.")
        return "save"
    print("\nWhat would you like to do?")
    print("1. Save changes (commit now)")
    print("2. Stash and re-apply after update")
    print("3. Cancel")
    response = input("Enter 1, 2, or 3: ")
    if response == "1":
        return "save"
    elif response == "2":
        return "stash"
    elif response == "3":
        print("Cancelled.")
        sys.exit(0)
    else:
        print("Invalid choice. Cancelled.")
        sys.exit(1)

def cmd_sync(non_interactive=False):
    root = repo_root()
    cfg = get_cfg(root)
    main = cfg["main"]
    cur = current_branch()

    if cur == main:
        print(f"✖ You’re on '{main}'. Run 'mel start [name]' first.")
        sys.exit(1)

    action = ensure_clean_or_handle(non_interactive=non_interactive)
    stashed = False
    if action == "save":
        ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
        commit_all(f"mel save @ {ts}")
    elif action == "stash":
        print("Stashing changes for sync...")
        run(["git", "stash", "push", "-m", "mel sync temp"])
        stashed = True

    fetch_origin()
    base_ref = f"origin/{main}" if has_remote("origin") else main

    strategy = (cfg.get("update_strategy") or "rebase").lower()
    print(f"🔄 Sync: updating {cur} with latest {main} via {strategy}...")
    if strategy == "merge":
        msg = format_merge_message(cfg, "sync", cur, main)
        try:
            if msg:
                run(["git", "merge", "--no-edit", "-m", msg, base_ref])
            else:
                run(["git", "merge", base_ref])
        except subprocess.CalledProcessError:
            print("✖ Merge hit conflicts. Fix files → git add -A && git merge --continue, or git merge --abort.")
            sys.exit(2)
    else:
        rebase_onto(base_ref)

    if stashed:
        print("Re-applying stashed changes...")
        rc, _ = run(["git", "stash", "pop"], check=False)
        if rc != 0:
            print("⚠️  Conflicts may have occurred while applying stashed changes. Resolve, then 'git add -A' and continue.")

    push_current(set_upstream=False)

    base = get_origin_web_url()
    if base and cfg.get("open_pr_on_sync"):
        if "github.com" in base:
            pr_url = f"{base}/compare/{main}...{cur}?expand=1"
            print(f"→ Opening PR: {pr_url}")
            open_url(pr_url)
        else:
            print("! open_pr_on_sync configured, but could not determine PR URL for this remote.")
    print("✓ Sync complete.")

def cmd_help():
    help_text = """
mel — a tiny helper for non‑engineers

Usage:
  mel start [name]     Create/reset a feature branch from main (prompts if omitted)
  mel save             Commit all, update with main, push
  mel sync             Save/stash as needed, update with main (rebase by default), push
  mel publish          Run tests, FF merge branch into main, push, rebase branch
  mel reset            Hard reset current feature branch to main and force-push
  mel status           Show summary (ahead/behind, dirty files, last commit) and git status
  mel update|pull      Update main or update current branch with latest main
  mel diff             Show staged and unstaged diff stats
  mel open [repo|branch|pr]  Open remote in browser
  mel test             Run configured test commands from .mel/config.json
  mel help             Show this help

Config (.mel/config.json):
  {
    "main": "main",
    "update_strategy": "rebase",  // or "merge"
    "test_commands": ["npm ci && npm test -s", "pytest -q --disable-warnings"],
    "open_pr_on_sync": true,
    "merge_message": "Merge {branch} into {main} by {author} @ {datetime}",
    "merge_message_after_sync": "Merge {branch} into {main}",
    "example_test_commands": ["npm ci && npm test -s", "pytest -q --disable-warnings"]
  }
"""
    print(help_text.strip())

def main():
    if len(sys.argv) < 2:
        cmd_help()
        sys.exit(0)
    yes_mode = (os.environ.get("MEL_YES") == "1" or "--yes" in sys.argv)
    args = [a for a in sys.argv[1:] if a != "--yes"]
    cmd = args[0]
    if cmd in ("help", "-h", "--help"):
        cmd_help()
    elif cmd == "start":
        if len(args) >= 2:
            branch = args[1]
        else:
            print("No branch provided.")
            entered = input("What's your name? We'll create a branch with it: ").strip()
            if not entered:
                print("✖ No name provided.")
                sys.exit(1)
            branch = entered
        cmd_start(sanitize_branch_name(branch))
    elif cmd == "save":
        cmd_save()
    elif cmd == "deploy":
        cmd_deploy()
    elif cmd == "publish":
        cmd_publish()
    elif cmd == "freshstart":
        cmd_freshstart()
    elif cmd == "reset":
        cmd_reset()
    elif cmd == "status":
        cmd_status()
    elif cmd == "pull":
        cmd_pull()
    elif cmd == "update":
        cmd_update()
    elif cmd == "test":
        cmd_test()
    elif cmd == "sync":
        cmd_sync(non_interactive=yes_mode)
    elif cmd == "open":
        target = args[1] if len(args) >= 2 else None
        cmd_open(target)
    elif cmd == "diff":
        cmd_diff()
    else:
        print(f"Unknown command: {cmd}")
        sys.exit(1)

if __name__ == "__main__":
    main()